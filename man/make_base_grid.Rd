% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/make_base_grid.R
\name{make_base_grid}
\alias{make_base_grid}
\title{Make a .tif file with appropriate extent, resolution and crs}
\usage{
make_base_grid(
  aoi,
  out_res = 90,
  out_epsg = 8059,
  lcm = 9000,
  name = "base",
  use_mask = NULL,
  out_file = NULL,
  values = 1,
  ret = "object",
  ...
)
}
\arguments{
\item{aoi}{sf from which an extent will be defined for the base grid}

\item{out_res}{Numeric. Desired resolution of the base grid}

\item{out_epsg}{Numeric. Appropriate \href{https://epsg.io/}{epsg} code to define
the coordinate reference system for the base grid}

\item{lcm}{Numeric. Least common multiple. The extent of the resulting base
grid will be divisible by lcm. Default 9000 is dervied by
numbers::mLCM(c(1, 2, 3, 4, 5, 10, 20, 30, 50, 90, 100, 500, 1000))}

\item{name}{Character. Name of the layer in the base grid}

\item{use_mask}{sf. Values in the bast grid outside of use_mask will be NA}

\item{out_file}{Character. Path into which to save the base grid}

\item{values}{Used to fill the base grid}

\item{...}{Passed to \code{terra::writeRaster()}. Usually datatype = "INT1U" and,
maybe, gdal = c("COMPRESS=NONE")}
}
\value{
spatRaster. If out_file supplied, the base grid is written to
out_file
}
\description{
Probably won't work well with decimal degress out_epsg
}
\examples{

  #library(envRaster)

  out_dir <- file.path(system.file(package = "envRaster"), "examples")

  cube_dir <- fs::path(out_dir, "cube")
  settings_path <- fs::path(cube_dir, "settings.rds")

  if(!file.exists(settings_path)) {

    source(fs::path(out_dir, "name_env_tif_ex.R"))

  }

  settings <- rio::import(settings_path)

  base <- make_base_grid(aoi # aoi is sf provided with envRaster
                         , out_res = 30
                         , out_epsg = 8059
                         , out_file = fs::path(cube_dir, "base.tif")
                         , datatype = "INT1U"
                         , overwrite = TRUE
                         )

  # Can't get indices with save_cube = FALSE but can pass cube onto apply_pixel
  cube <- get_sat_data(x = base
                       , start_date = "2023-01-01"
                       , end_date = "2023-12-31"
                       , collections = c("ga_ls9c_ard_3"
                                         , "ga_ls8c_ard_3"
                                         )
                       , property_filter = function(x) {x[["eo:cloud_cover"]] < 20}
                       , period = "P3M"
                       , layers = c("nir", "red")
                       , indices = NULL
                       , save_cube = FALSE
                       )

  if(FALSE) {

    # takes a minute or two
    cube \%>\%
      gdalcubes::apply_pixel("(nbart_nir - nbart_red) / (nbart_nir + nbart_red)", "ndvi") \%>\%
      gdalcubes::animate(col = viridis::viridis
                         , zlim = c(0, 1)
                         , downsample = FALSE
                         )

  }

  # Save a cube
  if(FALSE) {

    # takes a minute or two
    get_sat_data(x = base
                 , start_date = "2022-12-01"
                 , end_date = "2023-11-30"
                 , collections = settings$collection
                 , period = settings$period
                 , layers = NULL
                 , indices = list("ndvi" = c("nir", "red"))
                 , save_cube = TRUE
                 , out_dir = settings$out_dir

                 # passed to gdalcubes::write_tif
                 , creation_options = list("COMPRESS" = "NONE")
                 )

    # biggest contrast in ndvi in autumn. least contrast in spring
    ndvi_tifs <- fs::dir_ls(settings$out_dir, regexp = "tif$")

    ndvis <- terra::rast(ndvi_tifs)

    names(ndvis) <- gsub("ndvi__|\\\\.tif", "", basename(ndvi_tifs))

    terra::global(ndvis
                  , fun = \(x) quantile(x, probs = 0.75) - quantile(x, probs = 0.25)
                  )

    ndvis \%>\%
      terra::panel()

  }

}
